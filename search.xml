<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASCII表</title>
    <url>/2020/07/06/ASCII%E8%A1%A8/</url>
    <content><![CDATA[<p>ASCII查询表</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">ASCII值</th>
<th align="center">控制字符</th>
<th align="center">ASCII值</th>
<th align="center">控制字符</th>
<th align="center">ASCII值</th>
<th align="center">控制字符</th>
<th align="center">ASCII值</th>
<th align="center">控制字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">NUT</td>
<td align="center">32</td>
<td align="center">(space)</td>
<td align="center">64</td>
<td align="center">@</td>
<td align="center">96</td>
<td align="center">、</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SOH</td>
<td align="center">33</td>
<td align="center">!</td>
<td align="center">65</td>
<td align="center">A</td>
<td align="center">97</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">STX</td>
<td align="center">34</td>
<td align="center">“</td>
<td align="center">66</td>
<td align="center">B</td>
<td align="center">98</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">ETX</td>
<td align="center">35</td>
<td align="center">#</td>
<td align="center">67</td>
<td align="center">C</td>
<td align="center">99</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">EOT</td>
<td align="center">36</td>
<td align="center">$</td>
<td align="center">68</td>
<td align="center">D</td>
<td align="center">100</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">ENQ</td>
<td align="center">37</td>
<td align="center">%</td>
<td align="center">69</td>
<td align="center">E</td>
<td align="center">101</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">ACK</td>
<td align="center">38</td>
<td align="center">&amp;</td>
<td align="center">70</td>
<td align="center">F</td>
<td align="center">102</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">BEL</td>
<td align="center">39</td>
<td align="center">,</td>
<td align="center">71</td>
<td align="center">G</td>
<td align="center">103</td>
<td align="center">g</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">BS</td>
<td align="center">40</td>
<td align="center">(</td>
<td align="center">72</td>
<td align="center">H</td>
<td align="center">104</td>
<td align="center">h</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">HT</td>
<td align="center">41</td>
<td align="center">)</td>
<td align="center">73</td>
<td align="center">I</td>
<td align="center">105</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">LF</td>
<td align="center">42</td>
<td align="center">*</td>
<td align="center">74</td>
<td align="center">J</td>
<td align="center">106</td>
<td align="center">j</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">VT</td>
<td align="center">43</td>
<td align="center">+</td>
<td align="center">75</td>
<td align="center">K</td>
<td align="center">107</td>
<td align="center">k</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">FF</td>
<td align="center">44</td>
<td align="center">,</td>
<td align="center">76</td>
<td align="center">L</td>
<td align="center">108</td>
<td align="center">l</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">CR</td>
<td align="center">45</td>
<td align="center">-</td>
<td align="center">77</td>
<td align="center">M</td>
<td align="center">109</td>
<td align="center">m</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SO</td>
<td align="center">46</td>
<td align="center">.</td>
<td align="center">78</td>
<td align="center">N</td>
<td align="center">110</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SI</td>
<td align="center">47</td>
<td align="center">/</td>
<td align="center">79</td>
<td align="center">O</td>
<td align="center">111</td>
<td align="center">o</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">DLE</td>
<td align="center">48</td>
<td align="center">0</td>
<td align="center">80</td>
<td align="center">P</td>
<td align="center">112</td>
<td align="center">p</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">DCI</td>
<td align="center">49</td>
<td align="center">1</td>
<td align="center">81</td>
<td align="center">Q</td>
<td align="center">113</td>
<td align="center">q</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">DC2</td>
<td align="center">50</td>
<td align="center">2</td>
<td align="center">82</td>
<td align="center">R</td>
<td align="center">114</td>
<td align="center">r</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">DC3</td>
<td align="center">51</td>
<td align="center">3</td>
<td align="center">83</td>
<td align="center">S</td>
<td align="center">115</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">DC4</td>
<td align="center">52</td>
<td align="center">4</td>
<td align="center">84</td>
<td align="center">T</td>
<td align="center">116</td>
<td align="center">t</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">NAK</td>
<td align="center">53</td>
<td align="center">5</td>
<td align="center">85</td>
<td align="center">U</td>
<td align="center">117</td>
<td align="center">u</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">SYN</td>
<td align="center">54</td>
<td align="center">6</td>
<td align="center">86</td>
<td align="center">V</td>
<td align="center">118</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">TB</td>
<td align="center">55</td>
<td align="center">7</td>
<td align="center">87</td>
<td align="center">W</td>
<td align="center">119</td>
<td align="center">w</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">CAN</td>
<td align="center">56</td>
<td align="center">8</td>
<td align="center">88</td>
<td align="center">X</td>
<td align="center">120</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">EM</td>
<td align="center">57</td>
<td align="center">9</td>
<td align="center">89</td>
<td align="center">Y</td>
<td align="center">121</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">SUB</td>
<td align="center">58</td>
<td align="center">:</td>
<td align="center">90</td>
<td align="center">Z</td>
<td align="center">122</td>
<td align="center">z</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">ESC</td>
<td align="center">59</td>
<td align="center">;</td>
<td align="center">91</td>
<td align="center">[</td>
<td align="center">123</td>
<td align="center">{</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">FS</td>
<td align="center">60</td>
<td align="center">&lt;</td>
<td align="center">92</td>
<td align="center">/</td>
<td align="center">124</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">GS</td>
<td align="center">61</td>
<td align="center">=</td>
<td align="center">93</td>
<td align="center">]</td>
<td align="center">125</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">RS</td>
<td align="center">62</td>
<td align="center">&gt;</td>
<td align="center">94</td>
<td align="center">^</td>
<td align="center">126</td>
<td align="center">`</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">US</td>
<td align="center">63</td>
<td align="center">?</td>
<td align="center">95</td>
<td align="center">_</td>
<td align="center">127</td>
<td align="center">DEL</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode10 正则表达式匹配</title>
    <url>/2020/07/07/LeetCode10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;.&#x27;</span> 匹配任意单个字符</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: <span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;ab&quot;</span></span><br><span class="line">p = <span class="string">&quot;.*&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: <span class="string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="string">&#x27;*&#x27;</span>）任意字符（<span class="string">&#x27;.&#x27;</span>）。</span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="string">&#x27;c&#x27;</span> 为 <span class="number">0</span> 个, <span class="string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="string">&quot;aab&quot;</span>。</span><br></pre></td></tr></table></figure>


<p>示例 5:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;mississippi&quot;</span></span><br><span class="line">p = <span class="string">&quot;mis*is*p*.&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>方法一（动态规划）</p>
<ul>
<li>考虑字符串s和字符模型p，假设其长度分别为slen和plen,创建二维数组<code>flag[slen+1][plen+1]</code>来标记之前的字符串是否匹配.其中第一行代表字符串s为空的情况，第一列代表字符串p为空的情况。 比如说考虑字符串“<code>aab</code>” 与“<code>c*a*b</code>”.则如下图<code>flag[1][3]</code>为true表示字符串a与c*a匹配。以此类推，若<code>flag[slen][plen] = true</code>,那么表示字符串s和p可以匹配。那么现在的工作就是如何将这个二维数组填满。</li>
</ul>
<p><img src="images/1575035835804.png" alt="1575035835804"></p>
<ul>
<li><p>考虑<code>flag[i][j]</code>,对应字符串s和p中的值分别是<code>s.charAt(i-1)</code>和<code>p.charAt(j-1)</code>;</p>
<ol>
<li><p>若<code>p.charAt(j-1) == &#39;.&#39;;</code>那么无论<code>s.charAt(i-1)</code>是什么值，它们都将与其匹配，此时只要考虑在此之前的字符串是否匹配即可。即<code>flag[i-1][j-1]</code>是否为true；若为true，<code>flag[i][j] = true</code>；反之，<code>flag[i][j] = false</code>；继续标记下一个点。</p>
</li>
<li><p>若p.charAt(j-1) 是a~z中的任何一个值，那么当满足<code>s.charAt(i-1)==p.charAt(j-1)</code>时才能匹配，考虑之前的字符串是否匹配即可。即<code>flag[i-1][j-1]</code>是否为true；若为true，<code>flag[i][j] = true</code>；反之，<code>flag[i][j] = false</code>；继续标记下一个点。</p>
</li>
<li><p>若<code>p.charAt(j-1) == &#39;*&#39;</code>;此时分情况讨论：</p>
<p>1）若<code>flag[i][j-2] == true;</code>那么<code>flag[i][j] == true;</code>且必定为true；如下图，<code>flag[0][2] == true;</code></p>
<p>考虑<code>flag[0][4]</code>的位置，因为*代表匹配0个或多个字符串，所以当a为0个的时候，此时的字符串仍然匹配。</p>
<p><img src="images/1575038942557.png" alt="1575038942557"></p>
<p>2）若<code>flag[i][j-2] == false</code>；若<code>p.charAt(j-2) == &#39;.&#39;</code>，那么无论s.charAt(i-1)是什么值，都将与其匹配；若p.charAt(j-2) 是a~z中的任何一个值，那么当满足<code>s.charAt(i-1)==p.charAt(j-2)</code>时才能匹配。其中p.charAt(j-2)是<code>*</code>之前位置的值，注意此时并不能保证<code>flag[i][j] == true</code>;因为我们不能确定在此位置之前的字符串是否匹配。考虑<code>flag[2][4]</code>，当<code>flag[1][4] == true</code>时，说明之前的字符串已经匹配，那么增加一个相同的字符，同样匹配。那么我们就可以肯定此时<code>flag[2][4] == true</code>;若<code>flag[1][4]  == false;</code>那么既然之前字符串不匹配，那么在增加一个字符肯定也不会匹配，<code>flag[2][4] == false</code>;</p>
<p><img src="images/1575040597284.png" alt="1575040597284"></p>
<p>注意，我们不能像之前1和2中按照<code>flag[i-1][j-1]</code>的值判断是否匹配，我们将s中的b换成a，如下图，考虑<code>flag[3][4]</code>。<code>flag[2][3] == false;</code>因为如果存在多个重复的值，p中单个的值肯定不能与s当中多个重复的值匹配，也就是对于<code>flag[i][j],flag[i-1][j-1]</code>并不一直为true.</p>
<p><img src="images/1575041376866.png" alt="1575041376866"></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen+<span class="number">1</span>][plen+<span class="number">1</span>];</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    flag[i][j] = flag[i][j-<span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp;(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>)                                    || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; flag[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag[i][j] = i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>)                                  == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; flag[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，当前行的值只与当前行以及上一行有关，故可以优化一下空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length(), pLen = p.length();</span><br><span class="line">		<span class="keyword">boolean</span>[][] memory = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>][pLen+<span class="number">1</span>];</span><br><span class="line">		memory[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">			cur = i % <span class="number">2</span>;<span class="comment">//当前行</span></span><br><span class="line">			pre = (i + <span class="number">1</span>) % <span class="number">2</span>;<span class="comment">//当前行的上一行</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            除第一行外，每次标记之前，将当前行初始化，避免上一行影响，</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">			<span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= pLen; j++) </span><br><span class="line">                    memory[cur][j] = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">					memory[cur][j] = memory[cur][j-<span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; memory[pre][j]);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					memory[cur][j] = i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)&amp;&amp; memory[pre][j-<span class="number">1</span>];</span><br><span class="line">				&#125;&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> memory[cur][pLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（回溯）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp;</span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) ||</span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode10 正则表达式匹配</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>回溯算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode3 无重复字符的最长子串</title>
    <url>/2020/07/05/LeetCode3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a><strong>解答：</strong></h3><p>方法一：（优化的滑动窗口）</p>
<p>时间复杂度：O(N)  </p>
<p>空间复杂度：O(1) </p>
<p>此方法与方法二思想相似，下面介绍该方法的逻辑，</p>
<p>创建一个长度为128的数组，这是因为ASCII表中所有的值为128，这样创建的目的是数组的下标0-127刚好对应了ASCII表中的值，从字符串s中取出的值刚好作为下标来搜索无重复子串的开始和结束部分用于计算其长度。</p>
<p>对于已存在的ans数组，将从字符串中取出的值作为下标，其位置存储到数组当中，每当从字符串中取得一个值，将其在数组中存放的位置与原无重复子串的起点比较，取出较大的值，如其上一个位置较大，更新起点，否则不更新，然后判断是否更新无重复子串的最大长度。遍历整个字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.charAt(i);</span><br><span class="line">            start = ans[index] &gt; start?ans[index]:start;<span class="comment">//start = Math.max(start,ans[index]);</span></span><br><span class="line">            ans[index] = i+<span class="number">1</span>;</span><br><span class="line">            max = (i-start+<span class="number">1</span>) &gt; max?i-start+<span class="number">1</span>:max;<span class="comment">// max = Math(max,i-start+1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：（优化的滑动窗口）（同方法一）</p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(min(m,n))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(s.charAt(i)))</span><br><span class="line">             start = Math.max(start,map.get(s.charAt(i)));</span><br><span class="line">           max = Math.max(max,i-start+<span class="number">1</span>);</span><br><span class="line">           map.put(s.charAt(i),i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：（滑动窗口）</p>
<p>若集合中不存在该值，将其放入集合当中，若存在该值，则从原无重复子串起点开始，移除值，直到不存在该值时，停止，然后将其放入集合当中，计算长度，判断是否更新最大无重复字串的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源： <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3 无重复字符的最长子串</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode32 最长有效括号</title>
    <url>/2020/07/06/LeetCode32%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。 </p>
<a id="more"></a>    

<p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;(()&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 最长有效括号子串为 <span class="string">&quot;()&quot;</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;)()())&quot;</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长有效括号子串为 <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure>

<p>方法一：动态规划（时间复杂度：O(n),空间复杂度：O(n)）</p>
<p>先定义一个dp数组来存储有效字符串的最大长度，其长度为给定字符串的长度，其值全部初始化为0；对与一个给定的字符串，它的有效字符串长度必定以“）”结尾，我们只需更新其相对位置上的值即可，代表有效字符串的最大长度。其中所求子串必须连续。</p>
<p>分析：若某一位置i上元素为“）”，判断其i-1位置是否为“（”；若是，则更新dp[i] ;需要考虑dp[i-2]的值，但如果i&lt;2,dp[i]= dp[i-1]+2;反之dp[i]=dp[i-1] + dp[i-2] + 1;若不是，判断i - dp[i-1]-1位置上是否为“（”，若是，判断i-dp[i] &gt;= 2;若是，dp[i] = dp[i-1] + dp[i-2] + 2;反之，dp[i] = dp[i-1] + 2;</p>
<p>每遍历一次，就更新最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] bp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    bp[i] = (i &gt;= <span class="number">2</span> ? bp[i-<span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - bp[i-<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - bp[i-<span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    bp[i] = bp[i-<span class="number">1</span>] + (i-bp[i-<span class="number">1</span>]&gt;=<span class="number">2</span> ? bp[i-bp[i-<span class="number">1</span>] -<span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen,bp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（暴力栈）（时间复杂度：O(n^2),空间复杂度：O(n)）</p>
<p>观察所给示例，凡是符合条件的子串都是成对出现的，也就是说，符合要求的字串，只要出现几个“（”，那么就会随后就会出现几个“）”；所以说找出给定子串所有子串，然后进行判断是否是符合条件的子串，边判断边更新长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stack.empty() &amp;&amp; stack.peek() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= s.length(); j+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isValid(s.substring(i, j))) &#123;</span><br><span class="line">                    maxlen = Math.max(maxlen, j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三（优化栈）</p>
<p>理解为找一个垫底的位置作为参考，栈内存储坐标值而不是给定字符串中的字符，按照方法二的逻辑，括号总是成对出现的，一旦出现成对的括号，那么之后但凡不符合要求的就将它作为垫底元素。最后得到结果为当前值减去栈顶值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    maxLen = Math.max(maxLen,i-stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四（左右各遍历一遍）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题除了动态规划的方法之外，其他都是利用了括号的规律，即括号总是成对出现的，一旦出现了不匹配的字符，那么就要重新开始统计。方法四，左右都遍历一遍，因为只统计一遍得不到正确的结果。因为右括号总是要比左括号先出现。所以一旦左括号的数量比右括号多，那么需要重新统计，无论是方法二还是方法三还是方法四都利用了这个性质。只统计一编万一正确结果在左边界或者右边界那么得到的结果就是错误的。</p>
<p>题目来源： <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode32最长有小括号</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode7 整数反转</title>
    <url>/2020/07/05/LeetCode7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: -<span class="number">123</span></span><br><span class="line">输出: -<span class="number">321</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a><strong>解答：</strong></h3><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !=  <span class="number">0</span>)&#123;</span><br><span class="line">            num = num *<span class="number">10</span> +x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; Integer.MAX_VALUE || num &lt; Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>考虑一个int类型的数x，考虑其可能有溢出的可能，那么其第一位肯定小于等于2；因为最大正整数最后一位和最大负整数最后一位均大于2；所以不需要考虑最后一位，只需要比较除最后一位的前几位就可以了；因为取绝对值之后其他们的前几位都相同，所以翻转之后若得到的数大于这前几位，那么肯定会溢出，要是要与这前几位，那么由于最后一位只能取1或2，所以肯定不会溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java和c++中int占四个字节，也就是32位，其中第一位（最高位）为符号为，（1&lt;&lt;31）表示1左移31位，使得符号位为1，其他位为0，再将左移后的结果减一就使得符号位为0，其他位都为1，即为int表示的有符号数的最大整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">&lt;&lt;为位运算中的左移，a&lt;&lt;b表示a向左移动b位，移动后在末尾最低位补0，如1&lt;&lt;2得到100，即10进制的4</span></span><br><span class="line"><span class="comment">对应的&gt;&gt;为位运算中的右移，a&gt;&gt;b表示a向右移动b位，与左移不同的是，如果a为负数，右移后在最高位补1，如果a为正数，右移后在最高位补0 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Integer.MIX_VALUE = 1 &lt;&lt; 31</span></span><br><span class="line"><span class="comment">Integer.MAX_VALUE = (1 &lt;&lt; 31) - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(res) &gt; Integer.MAX_VALUE/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题目来源： <a href="https://leetcode-cn.com/problems/reverse-integer/">LeetCode 7 整数反转</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode8 字符串转换整数</title>
    <url>/2020/07/06/LeetCode8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<a id="more"></a>

<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;42&quot;</span></span><br><span class="line">输出: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出: -<span class="number">42</span></span><br><span class="line">解释: 第一个非空白字符为 <span class="string">&#x27;-&#x27;</span>, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -<span class="number">42</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出: <span class="number">4193</span></span><br><span class="line">解释: 转换截止于数字 <span class="string">&#x27;3&#x27;</span> ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;words and 987&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 第一个非空字符是 <span class="string">&#x27;w&#x27;</span>, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;-91283472332&quot;</span></span><br><span class="line">输出: -<span class="number">2147483648</span></span><br><span class="line">解释: 数字 <span class="string">&quot;-91283472332&quot;</span> 超过 <span class="number">32</span> 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure>

<p>我的思路：尴尬 思路不清晰  错了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str == <span class="string">&quot;&quot;</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                flag = str.charAt(i) == <span class="string">&#x27;-&#x27;</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) &lt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &gt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                end = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = str.substring(start,end);</span><br><span class="line">        <span class="keyword">int</span> len = newStr.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">10</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span>(len &lt; <span class="number">10</span>) <span class="keyword">return</span> Integer.parseInt(newStr);</span><br><span class="line">            <span class="keyword">int</span> ans = Integer.parseInt(newStr.substring(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">int</span> a = Integer.parseInt(newStr.substring(<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; (<span class="number">1</span>&lt;&lt;<span class="number">31</span>-<span class="number">1</span>)/<span class="number">10</span> || ans == (<span class="number">1</span>&lt;&lt;<span class="number">31</span>-<span class="number">1</span>)/<span class="number">10</span> &amp;&amp; a &gt;=<span class="number">7</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> Integer.parseInt(newStr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">11</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span>(len &lt; <span class="number">11</span>) <span class="keyword">return</span> Integer.parseInt(newStr);</span><br><span class="line">            <span class="keyword">int</span> ans = Integer.parseInt(newStr.substring(<span class="number">0</span>,<span class="number">11</span>));</span><br><span class="line">            <span class="keyword">int</span> a = Integer.parseInt(newStr.substring(<span class="number">11</span>));</span><br><span class="line">            <span class="keyword">if</span>(ans &lt; <span class="number">1</span>&lt;&lt;<span class="number">31</span>/<span class="number">10</span> || ans == <span class="number">1</span>&lt;&lt;<span class="number">31</span>/<span class="number">10</span> &amp;&amp; a &gt;=<span class="number">8</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> Integer.parseInt(newStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑分析：</strong></p>
<p>1、将给定的字符串开始的空格去掉；</p>
<p>2，判断去掉空格之后的字符串是否为空，若为空，返回0；否则继续下一步；</p>
<p>3、判断第一位是否是允许出现的符号，考虑“+”、“-”，“0~9”，若不是他们的话，就返回0；不然的话就进行下一步。</p>
<p>4、现在可以知道下面这个字符串是一个有可能是一个符合要求的数字了，然后开始截取字符串，此时允许出现的字符串只有“0~9”；如果是的话，就开始截取截取，不是的话，结束循环；</p>
<p>5、这时候我们的得到了一个新的字符串。但是现在并不能确定字符串是否能够转换为数字；考虑以下三种情况：</p>
<p>（1） 当开始截取的时候，字符串等于“+”或者“-”，说明不能转换为数字；返回0；</p>
<p>（2）可以截取数字，但是会超过int类型数字的最大值，或者小于int类型的最小值，那么在进行转换的时候需要考虑捕获异常；若没有捕获到异常，正常进行转换，不然的话就判断第一位是否为“-”，若为“-”，返回Integer.MAX_VALUE,不然的话，返回Integer.MIN_VALUE</p>
<p>(3)最后返回转换后的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        String strr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> || str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span> || (str.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">            strr = str.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) strr = str.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(strr == <span class="keyword">null</span> || strr.equals(<span class="string">&quot;+&quot;</span>) || strr.equals(<span class="string">&quot;-&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            num = Integer.parseInt(strr);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">LeetCode8 字符串转换整数</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode9 回文数</title>
    <url>/2020/07/06/LeetCode9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: -<span class="number">121</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 从左向右读, 为 -<span class="number">121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<p>这道题是#7题的延伸，对于给定的数x，考虑如下：</p>
<p>1 、x为负数，那么它肯定不是回文数，返回false；</p>
<p>2、翻转x，然后将其与原数字比较，相等返回true，不等则返回false；这里应当注意的是，不需要考虑溢出的问题，理由如下：</p>
<p>（1）若x为回文数，那么翻转过后的数字肯定也是回文数，不会溢出；</p>
<p>（2）若x不是回文数，若不会溢出，直接比较即可，若会溢出，那么溢出的值等于翻转过后的值截取前32位即可，两者肯定不会相等（万一相等了怎么办？但是能保证一般不会相等），故也直接比较就行了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = x;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans != <span class="number">0</span>)&#123;</span><br><span class="line">            num = num*<span class="number">10</span> + ans%<span class="number">10</span>;</span><br><span class="line">            ans /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == x ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源：<a href="https://leetcode-cn.com/problems/palindrome-number/">LeetCode9 回文数</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制的表示以及左移右移</title>
    <url>/2020/07/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%BB%A5%E5%8F%8A%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB/</url>
    <content><![CDATA[<p>在二进制中，负值以其正值的补码形式保存。</p>
<a id="more"></a>

<p><strong>原码：</strong>一个整数，按照绝对值大小转换成的二进制数，称为原码</p>
<p>eg.  5的原码：0000 0000 0000 0000 0000 0000 0000 0101</p>
<p><strong>反码：</strong>将二进制数按位取反，所得的新二进制数称为原二进制数的反码。（反码是相互的）</p>
<p>eg.  5的反码：1111 1111 1111 1111 1111 1111 1111 1010</p>
<p><strong>补码：</strong>反码加1称为补码，也就是说，要得到一个补码，应先得到反码，然后在加1；</p>
<p>eg. 5的补码： 1111 1111 1111 1111 1111 1111 1111 1011（-5）</p>
<p><strong>在计算机中的表示：</strong> 正数的补码和原码、反码相同；负数补码是在反码加1。</p>
<p><strong>在不溢出的情况下：</strong></p>
<p>左移n位后的值 等于原值乘以2的n次方</p>
<p>例如 4 &lt;&lt;2 就是16，二进制就是 00000100 &lt;&lt;00010000</p>
<p>-4&lt;&lt;2 就是-16  二进制就是 11111100 &lt;&lt;11110000</p>
<p>右移n位后的值 等于原值除以2的n次方的商</p>
<p>例如 4 &gt;&gt;2 就是1，二进制就是 00000100 &gt;&gt;00000001</p>
<p>-4&gt;&gt;2 就是-1  二进制就是 11111100 &lt;&lt;11111111</p>
<h4 id="二进制的左移右移"><a href="#二进制的左移右移" class="headerlink" title="二进制的左移右移"></a>二进制的左移右移</h4><ul>
<li>&lt;&lt;  表示左移，不分正负数，低位补0</li>
<li>&gt;&gt;  表示右移，如果该数为正，则高位补0，若为负数，则高位补1</li>
<li>&gt;&gt;&gt; 表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0，正数的&gt;&gt;&gt;相当于&gt;&gt;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;16 &lt;&lt; 1 : &quot;</span> + (<span class="number">16</span> &lt;&lt; <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;16 &gt;&gt; 3 : &quot;</span> + (<span class="number">16</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;16 &gt;&gt; 10 : &quot;</span> + (<span class="number">16</span> &gt;&gt; <span class="number">10</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;1 &gt;&gt; 1 : &quot;</span> + (<span class="number">1</span> &gt;&gt; <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;16 &gt;&gt;&gt; 2 : &quot;</span> + (<span class="number">16</span> &gt;&gt;&gt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-16 &gt;&gt; 2 : &quot;</span> + (-<span class="number">16</span> &gt;&gt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-16 &lt;&lt; 2 : &quot;</span> + (-<span class="number">16</span> &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-16 &gt;&gt;&gt; 2 : &quot;</span> + (-<span class="number">16</span> &gt;&gt;&gt; <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16 &lt;&lt; 1 : 32</span><br><span class="line">16 &gt;&gt; 3 : 2</span><br><span class="line">16 &gt;&gt; 10 : 0</span><br><span class="line">1 &gt;&gt; 1 : 0</span><br><span class="line">16 &gt;&gt;&gt; 2 : 4</span><br><span class="line">-16 &gt;&gt; 2 : -4</span><br><span class="line">-16 &lt;&lt; 2 : -64</span><br><span class="line">-16 &gt;&gt;&gt; 2 : 1073741820</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>补码</tag>
        <tag>二进制</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开与逆康托展开</title>
    <url>/2020/07/06/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E4%B8%8E%E9%80%86%E5%BA%B7%E6%8B%93%E5%B1%95%E5%8D%A1/</url>
    <content><![CDATA[<p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>
<a id="more"></a>

<p>​       康托展开的公式为：<br>$$<br>rank = a_n(n-1)! + a_{n-1}(n-2)!+…+a_10!<br>$$<br>其中a<del>i</del>为整数，并且:<br>$$<br>0\leq a_i &lt; i, 1\leq i\leq n<br>$$<br>a<del>i</del>表示原数的第i位在当前未出现的元素中是排在第几个。</p>
<p>1）<strong>康托展开</strong>（注意：如果排名是从1开始的话，最终结果应当再+1）</p>
<p>给定一个全排列，计算其字典序。直观起见，我们举例[2, 3, 4, 1]来说明康托展开的运作步骤：<br>命所求字典序为 rank=0；</p>
<ol>
<li><p>第 1 位是 2， 那么以 1 打头的所有全排列一定排在这个全排列之前，那么以 1 打头的全排列有 (3!) = 6种，rank = rank + 1∗3! = 6；</p>
</li>
<li><p>第 2 位是 3，那么以 1 与 2 作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不需要再考虑 2 占第二位的情况，只需要计算 1 占第二位的情况。rank = rank + 1∗2! = 8；</p>
</li>
<li><p>第三位是 4，同时，我们计算以 1 占第三位的所有情况。rank = rank + 1∗1! = 9；<br>最后一位，是不需要判定的，因为前 n−1位给定后，第 n 位自定。当然，为了也适应前面推导，可以记 rank = rank + 0∗0! = 9；</p>
</li>
<li><p>由是，排在 [2, 3, 4, 1] 之前的全排列共有 9 个，那么 [2, 3, 4, 1] 应当是第 10 个全排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] factorials = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        factorials[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> factorial = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            candidates.add(i);</span><br><span class="line">            factorial *= i;</span><br><span class="line">            factorials[i] = factorial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = candidates.indexOf(nums[i]);</span><br><span class="line">            sum = sum + k*factorials[n-i-<span class="number">1</span>];</span><br><span class="line">            candidates.remove(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]==<span class="number">1</span>?sum+<span class="number">1</span>:sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>2）<strong>逆康托展开</strong></p>
<p>同样以[2, 3, 4, 1]为例，以说明逆康拓展开的执行方法。这里输入和输出互反，同时，我们还需要输入全排列的字符个数(否则有无穷多个解)。<br>给定，字符个数 4，字典序序号 10，首先字典序 - 1 得到排在该字典序前的全排列个数，然后：</p>
<ol>
<li>9 / 3! 结果，商 1 余 3，说明首位要余出一个给 当前没用过的，最小的一个字符，因为它们占据了前 6 个排序。这里 “1” 没有用过，又是最小的字符，因此，我们应当使用 “2” 作为首位，并标记其已经使用。取余数进行下一步操作。</li>
<li>3 / 2! 结果，商 1 余 1，说明第二位要余出一个给 当前没用过的，最小的字符。这里 “1” 没有用过，“2” 已经用了。因此，我们应当使用 “3” 作第二位。</li>
<li>1 / 1! 结果，商 1 余 0，说明第三位要余出一个给 当前没用过的，最小的字符。这里 “1” 没有用过，“2” 已经用了，“3”也用了。因此，我们应当使用 “4” 作第三位。</li>
<li>同康托展开，最后一位无需判断，所有字符中至今未使用的填入即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode#60题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] factorials = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        factorials[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> factorial = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            candidates.add(i);</span><br><span class="line">            factorial *= i;</span><br><span class="line">            factorials[i] = factorial;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = k/factorials[i];</span><br><span class="line">            sb.append(candidates.remove(index));</span><br><span class="line">            k -= index*factorials[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与字符串之间的相互转换</title>
    <url>/2020/07/07/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>–</p>
<a id="more"></a>

<h4 id="1-字符串转数组"><a href="#1-字符串转数组" class="headerlink" title="1 字符串转数组"></a>1 字符串转数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于给定的字符串str</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//注意：. | * 等转义字符，必须要加\，可以用|作为连字符</span></span><br><span class="line">String str = <span class="string">&quot;0,1,2,3,4,5&quot;</span>;</span><br><span class="line">String[] arr = str.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//用&quot;,&quot;分割</span></span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[0,1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">String str1 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">char</span>[str1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    arr1[i] = str1.charAt(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr1));<span class="comment">//[0,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-数组转字符串"><a href="#2-数组转字符串" class="headerlink" title="2 数组转字符串"></a>2 数组转字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于给定的字符串</span></span><br><span class="line">String[] arr = &#123; <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一 遍历</span></span><br><span class="line">StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">    str2.append(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 使用StringUtils的join方法</span></span><br><span class="line"><span class="comment">//数组转字符串 org.apache.commons.lang3.StringUtils</span></span><br><span class="line"> </span><br><span class="line">String str3 = StringUtils.join(arr); <span class="comment">// 数组转字符串,其实使用的也是遍历</span></span><br><span class="line">System.out.println(str3); <span class="comment">// 012345</span></span><br><span class="line">String str4 = StringUtils.join(arr, <span class="string">&quot;,&quot;</span>); <span class="comment">// 数组转字符串(逗号分隔)(推荐) </span></span><br><span class="line">System.out.println(str4); <span class="comment">// 0,1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三 使用ArrayUtils的toString方法</span></span><br><span class="line"><span class="comment">// 数组转字符串 org.apache.commons.lang3.ArrayUtils</span></span><br><span class="line"></span><br><span class="line">String str2 = ArrayUtils.toString(arr, <span class="string">&quot;,&quot;</span>); <span class="comment">// 数组转字符串(逗号分隔,首尾加大括号)</span></span><br><span class="line">System.out.println(str2); <span class="comment">// &#123;0,1,2,3,4,5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法四 不通用 arr需要是byte[]、char[]数组。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序</title>
    <url>/2020/07/10/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本篇介绍常用排序，包括选择排序、插入排序、冒泡排序和快速排序。</p>
<a id="more"></a>

<h5 id="8-1-选择排序"><a href="#8-1-选择排序" class="headerlink" title="8.1 选择排序"></a>8.1 选择排序</h5><p><strong>基本思想：</strong> 从数组中找到最小的元素，和第一个位置的元素互换，从第二个位置开始，找到最小的元素，和第二个位置的元素互换，重复上述操作，直到选出array.length - 1较小元素，剩下最大的元素自动排在最后一位。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">         <span class="comment">//int minValue = nums[i];</span></span><br><span class="line">         <span class="keyword">int</span> minPos = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[j] &lt; nums[minPos])&#123;</span><br><span class="line">                 <span class="comment">//minValue = nums[j];</span></span><br><span class="line">                 minPos = j;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         swap(nums,i,index);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>衍生算法（双向选择排序）：</strong>将最小值放在前面，最大值放在后面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i, maxPos = nums.length - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length - i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minPos]) minPos = j;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[maxPos]) maxPos = j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,minPos);</span><br><span class="line">            <span class="keyword">if</span>(maxPos == i) maxPos = minPos;</span><br><span class="line">            swap(nums,nums.length - i -<span class="number">1</span>,maxPos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h5><p>从第二个元素开始，将当前元素插入到前面对应元素，使当前元素i和之前元素形成有序数组。</p>
<p><strong>比较规则</strong></p>
<p>正常：从第一个元素开始，若当前元素i小于有序数组的元素j，则从该元素开始将有序数组依次往后移一位，并将当前元素i放置到该元素j位置。</p>
<p>简易：从有序数组最后一个元素开始，若当前元素i小于该元素j，则交换当前元素和该元素；</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> pos = i;</span><br><span class="line">          <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[pos - <span class="number">1</span>])&#123;</span><br><span class="line">              swap(nums,pos,pos-<span class="number">1</span>);</span><br><span class="line">              pos--;       </span><br><span class="line">          &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[pos1];</span><br><span class="line">      nums[pos1] = nums[pos2];</span><br><span class="line">      nums[pos2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-3-冒泡排序"><a href="#8-3-冒泡排序" class="headerlink" title="8.3 冒泡排序"></a>8.3 冒泡排序</h5><p>基本思想：从前往后，依次比较相邻的两个数，把较大的数放在后面，一次循环，可以在当前最末位位置得到一个当前的最大值。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码改进：</strong>设置标志变量change</p>
<p>标志变量用于记录每趟冒泡排序是否发生数据元素位置交换，如果没有发生交换，说明序列已经有序了，不必继续进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> change = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                change = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(change == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>鸡尾酒排序：</strong></p>
<p>鸡尾酒排序是冒泡排序的升级版，该排序从左往右找出最大值之后，再从右往左找出最小值，类似鸡尾酒搅拌左右循环，在某些情况下，优于冒泡排序。</p>
<p>以**序列(2,3,4,5,1)**为例，鸡尾酒排序只需要访问两次（升序降序各一次 ）次序列就可以完成排序，但如果使用冒泡排序则需要四次。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">      <span class="keyword">int</span> change = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">          change = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i -<span class="number">1</span>; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                  change = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(change == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          change = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = nums.length - i - <span class="number">1</span>; k &gt; i; k--)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[k] &lt; nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                  swap(nums,k,k-<span class="number">1</span>);</span><br><span class="line">                  change = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(change == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>; right = nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right; i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                 swap(nums,i,i+<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         right--;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt; left; i--)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                 swap(nums,i,i-<span class="number">1</span>)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position1, <span class="keyword">int</span> position2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[position1];</span><br><span class="line">      nums[position1] = nums[position2];</span><br><span class="line">      nums[position2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-4-快速排序"><a href="#8-4-快速排序" class="headerlink" title="8.4 快速排序"></a>8.4 快速排序</h5><p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p><strong>基本思想：</strong></p>
<ol>
<li>从数列中取出一个数作为基准数</li>
<li>分区过程，将比这个数大的数全放在它的右边，小于或等于他的数全放在它的左边；</li>
<li>对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p>概括来说，就是<strong>挖坑填数+分治法</strong></p>
<p>举例说明（以数组[72,6,57,88,60,42,83,73,48,85]为例）：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td><strong>72</strong></td>
<td>6</td>
<td>57</td>
<td>88</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td><strong>48</strong></td>
<td>85</td>
</tr>
</tbody></table>
<p>初始时，i = 0;  j = 9;   X = a[i] = 72</p>
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p>
<p>数组变为：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td><strong>48</strong></td>
<td>6</td>
<td>57</td>
<td><strong>88</strong></td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td><strong>88</strong></td>
<td>85</td>
</tr>
</tbody></table>
<p> i = 3;   j = 7;   X=72</p>
<p>再重复上面的步骤，<strong>先从后向前找，再从前向后找</strong>。</p>
<p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p>
<p>从i开始向后找，当i=5时，由于i==j退出。</p>
<p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p>
<p>数组变为：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td><strong>48</strong></td>
<td>6</td>
<td>57</td>
<td><strong>42</strong></td>
<td>60</td>
<td><strong>72</strong></td>
<td>83</td>
<td>73</td>
<td><strong>88</strong></td>
<td>85</td>
</tr>
</tbody></table>
<p>可以<strong>看出a[5]前面的数字都小于它，a[5]后面的数字都大于它</strong>。因此再对a[0…4]和a[6…9]这二个子区间<strong>重复</strong>上述步骤就可以了。</p>
<p>总结如下：</p>
<ol>
<li>i = L；j = R；将基准数挖出形成第一个坑a[i];</li>
<li>j–由后向前找比它小的数，找到后挖出此数填在前一个坑a[i]中；</li>
<li>i++由前到后找比它大的数，找到后也挖出此数填在前一个坑a[i]中；</li>
<li>在重复2，3步，直到i==j，将基准数填入a[i]中。</li>
</ol>
<p><strong>实现代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) j--;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; j) s[i++] = s[j];</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt;= x) i++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; j) s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i == j) s[i] = x;</span><br><span class="line">            sort(nums,l,i-<span class="number">1</span>);</span><br><span class="line">            sort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>BFPRT算法(Top-K问题)</title>
    <url>/2020/07/11/BFPRT%E7%AE%97%E6%B3%95-Top-K%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在BFPRT算法中，仅仅是改变了快速排序Partion中pivot值的选取，在快速排序中，我们始终选取第一个或最有一个元素作为pivot，而在BFPRT算法中，<a id="more"></a>选择五分中位数的中位数作为Pivot，然后进行Partion，这样的目的就是是的划分比较合适，从而避免了最坏情况的发生。所以我们的工作就是在快速选择的基础上找到合适的pivot即可。可以发现，与上述算法的不同之处仅在于pivot的不同</p>
<p>下面讨论如何找到合适的pivot：</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>对于数组内的n个元素进行分组处理，每组5个元素，如剩下的元素不足5个，也作为一组元素处理。</p>
</li>
<li><p>对分组后的元素按组进行排序，这里使用<strong>插入排序</strong>，然后分别获取中位数，并将得到的中位数移动到数组头部，方便下一次处理；</p>
</li>
<li><p>对于步骤2中得到的中位数继续进行步骤1和2进行处理，直到只剩下一个数，然后取出该值作为pivot，然后进行Partion；</p>
</li>
<li><p>对步骤3得到的区间继续进行按照步骤1，2，3进行处理，直至得到符合条件的值。</p>
</li>
</ol>
<p>首先我们需要了解一下算法的实现过程：</p>
<p><strong>交换数组不同位置的值：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[pos1];</span><br><span class="line">      nums[pos1] = nums[pos2];</span><br><span class="line">      nums[pos2] = temp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> pos = i;</span><br><span class="line">         <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[pos - <span class="number">1</span>])&#123;</span><br><span class="line">             swap(nums,pos,pos-<span class="number">1</span>);</span><br><span class="line">             pos--;       </span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取privot：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMidNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//分组得到中位数，</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; right - <span class="number">5</span>; i+=<span class="number">5</span>)&#123;</span><br><span class="line">          insertSort(nums,i,i+<span class="number">4</span>);</span><br><span class="line">          swap(nums,left+(i-left)/<span class="number">5</span>,i+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; right)&#123;</span><br><span class="line">            insertSort(nums,i,right);</span><br><span class="line">            swap(nums,left+(i-left)/<span class="number">5</span>,i+(right - i)/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归寻找得到的中位数的中位数</span></span><br><span class="line">        <span class="keyword">return</span> getMidNum(nums,left,left+(i - left)/<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right, x = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= x) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) nums[i++] = nums[j];</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt;= x) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) nums[j--] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i == j) nums[i] = x;</span><br><span class="line">        sort(nums,left,i-<span class="number">1</span>);</span><br><span class="line">        sort(nums,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = nums.length - k;</span><br><span class="line">        quickSort(nums,k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="comment">//利用之前的快速选择排序即可，把参考值换成我们经过计算得到的参考值即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = left, j = right, x = getMidNum(nums,left,right);</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= x) j--;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; j) nums[i++] = nums[j];</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= x) i++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; j) nums[j--] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i == j) nums[i] = x;</span><br><span class="line">            <span class="keyword">if</span>(i == k) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; i) quickSort(nums,k,left,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> quickSort(nums,k,i+<span class="number">1</span>,right);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取符合要求的中位数</span></span><br><span class="line">    <span class="comment">//由于在递归的过程中获取中位数的区间不同，所以需要限制区间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMidNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; right - <span class="number">5</span>; i+=<span class="number">5</span>)&#123;</span><br><span class="line">          insertSort(nums,i,i+<span class="number">4</span>);</span><br><span class="line">          swap(nums,left+(i-left)/<span class="number">5</span>,i+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; right)&#123;</span><br><span class="line">            insertSort(nums,i,right);</span><br><span class="line">            swap(nums,left+(i-left)/<span class="number">5</span>,i+(right - i)/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMidNum(nums,left,left+(i - left)/<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="comment">//由于要实现局部排序，需要限制排序区间</span></span><br><span class="line">    <span class="comment">//根据要求修改代码如下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> pos = i;</span><br><span class="line">          <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[pos - <span class="number">1</span>])&#123;</span><br><span class="line">              swap(nums,pos,pos-<span class="number">1</span>);</span><br><span class="line">              pos--;       </span><br><span class="line">          &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换数组中两个元素的位置</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[pos1];</span><br><span class="line">      nums[pos1] = nums[pos2];</span><br><span class="line">      nums[pos2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 43 字符串相乘</title>
    <url>/2020/07/12/LeetCode43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<a id="more"></a>    

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: num1 = <span class="string">&quot;2&quot;</span>, num2 = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出: <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: num1 = <span class="string">&quot;123&quot;</span>, num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><p>num1 和 num2 的长度小于110。</p>
</li>
<li><p>num1 和 num2 只包含数字 0-9。</p>
</li>
<li><p>num1 和 num2 均不以零开头，除非是数字 0 本身。</p>
</li>
<li><p><strong>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</strong></p>
</li>
</ol>
<p><strong>方法一：</strong></p>
<p>#415字符串相加的升级版，但是相加的数字要比#415多得多，思路很简单，按照两数相乘的基本原理进行相加即可，这个过程看代码应该可以理解。</p>
<p>首先考虑数据的存放问题，在#415当中，我们处理的方法是将相加过后直接将数据放入str当中，进位值carry进行下一次运算，这是因为我们不需要考虑更新的问题，在这道题当中，因为数据比较多，而且每进行一次相加，那么数据就应该更新一次，所以我们可以考虑将数组放入数组中，然后通过实时更新数组的方式，得到最终的结果；</p>
<p>然后考虑怎么更新数组，也就是考虑怎么控制数组下标的变化：</p>
<p>1）首先考虑一个总体上数组下标的更新，保证内部更新完数组之后，下次开始更新的位置在其起始位的前一位；</p>
<p>2）其次考虑内部的数组下表的更新；直接更新即可，不过要保证其开始值为1）当中得到的起始位；</p>
<p>最后将得到的数组转换为字符串即可；</p>
<p>注意：需要考虑两数相乘的数组长度为m+n或m+n-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> index = m+n-<span class="number">1</span>;<span class="comment">//该下标用于总体上的更新；</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> index1 = index;<span class="comment">//该下标用于内部更新</span></span><br><span class="line">            <span class="keyword">int</span> a = num1.charAt(i)-<span class="number">48</span>;</span><br><span class="line">               <span class="comment">//更新数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123; </span><br><span class="line">                <span class="keyword">int</span> b = num2.charAt(j)-<span class="number">48</span>;</span><br><span class="line">                <span class="keyword">int</span> mu = a*b+carry+nums[index1];</span><br><span class="line">                carry = mu/<span class="number">10</span>;</span><br><span class="line">                nums[index1] = mu%<span class="number">10</span>;</span><br><span class="line">                index1--;</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="comment">//进位</span></span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">            	nums[index1] = carry;</span><br><span class="line">            	carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//将数组转换为字符串</span></span><br><span class="line">         StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">             str.append(nums[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> str.toString();</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>在方法一基础上做的优化，对下标进行优化</p>
<p>时间复杂度和空间复杂度相同</p>
<p>时间复杂度：O(MN)   空间复杂度：O(M+N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">	            <span class="keyword">int</span> a = num1.charAt(i)-<span class="number">48</span>;</span><br><span class="line">	            <span class="keyword">for</span>(<span class="keyword">int</span> j = num2.length()-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123; </span><br><span class="line">	                <span class="keyword">int</span> b = num2.charAt(j)-<span class="number">48</span>;</span><br><span class="line">	                <span class="keyword">int</span> sum = a*b+nums[i+j+<span class="number">1</span>];</span><br><span class="line">	                nums[i+j+<span class="number">1</span>] = sum%<span class="number">10</span>;</span><br><span class="line">                    nums[i+j] += sum/<span class="number">10</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	         StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">	             <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	             str.append(nums[i]);</span><br><span class="line">	         &#125;</span><br><span class="line">	         <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源：<a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode43 字符串相乘</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode50 Pow(x, n)</title>
    <url>/2020/07/15/LeetCode50-Pow-x-n/</url>
    <content><![CDATA[<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<a id="more"></a>    

<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2.00000</span>, <span class="number">10</span></span><br><span class="line">输出: <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2.10000</span>, <span class="number">3</span></span><br><span class="line">输出: <span class="number">9.26100</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2.00000</span>, -<span class="number">2</span></span><br><span class="line">输出: <span class="number">0.25000</span></span><br><span class="line">解释: <span class="number">2</span>-<span class="number">2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<p>尝试一：</p>
<p>思路应该是对的，但肯定会超时，使用#29的思路进行优化；（暴力法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">           result *= x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试二：</p>
<p>尝试失败，使用#29的思路依旧超时！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            n = ~n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> result = x;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">          result *= result;</span><br><span class="line">          i += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num = result * myPow(x,n-i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法一：（递归）</strong></p>
<p>理解：将数据分为两组，然后在这两组的基础上进行递归操作，继续分组，最后若分组结果为偶数，则直接将之前得到的值相乘即可，若为奇数，需除了将之前得到的值进行相乘，还要乘上一个x，这是因为n/2的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fastPow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> half * half * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span>?fastPow(x, n):<span class="number">1</span>/fastPow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>理解：每一次循环将原数据重新分组，落单的部分ans相乘，然后继续分组，最终合并为一组，将该组结果与ans相乘，得到最终结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> current_product = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = N; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * current_product;</span><br><span class="line">            &#125;</span><br><span class="line">            current_product = current_product * current_product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>其实在计算最终结果的时候不用考虑n的正负，因为我们判定边界的依据并不是根据n的大小，而是每一次将n值进行二分的时候最终结果是否为0来进行判断的，无论n正负，其实结果是一样的。</p>
<p>题目来源：<a href="https://leetcode-cn.com/problems/powx-n/">LeetCode50 Pow(x,n)</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/07/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树的所有节点，使得每个节点被访问一次且仅被访问一次。</p>
<a id="more"></a>

<p>对于二叉树，分为<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong>，深度优先遍历又分为<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>；广度优先遍历也叫做层序遍历或层次遍历。</p>
<p>首先定义一个二叉树，下面的算法都在此二叉树上操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="10-1-深度优先搜索-DFS"><a href="#10-1-深度优先搜索-DFS" class="headerlink" title="10.1 深度优先搜索(DFS)"></a>10.1 深度优先搜索(DFS)</h5><h6 id="10-1-1-前序遍历（中-左-右）"><a href="#10-1-1-前序遍历（中-左-右）" class="headerlink" title="10.1.1 前序遍历（中-左-右）"></a>10.1.1 前序遍历（中-左-右）</h6><p>若树为空，则空操作返回，否则，先访问根节点，然后前序遍历左子树，最后前序遍历右子树。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1581340009601.png" alt="1581340009601"></p>
<p>上图按照<strong>前序遍历</strong>顺序为：ABDHIEJCFKG</p>
<p><strong>代码实现：</strong></p>
<p>方法一（递归）：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(h)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;TreeNode&gt; <span class="title">preorderRecursion</span><span class="params">(TreeNode node, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        array.add(node);</span><br><span class="line">        preorder(node.left,array);</span><br><span class="line">        preorder(node.right,array);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（迭代）：</p>
<p>时间复杂度：O(n)，其中n是树的节点数</p>
<p>空间复杂度：O(k)，k是栈的最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">preorderIteration</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                array.add(root);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法三（莫里斯算法）：</p>
<p>时间复杂度：O(n)，n是树的节点数</p>
<p>空间复杂度：O(1),没有借助额外的辅助空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">preorderIteration</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">       TreeNode curNode = root, preNode = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(curNode.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">               array.add(curNode);</span><br><span class="line">               curNode = curNode.right;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               preNode = curNode.left;</span><br><span class="line">               <span class="keyword">while</span>(preNode.right != <span class="keyword">null</span>) preNode = preNode.right;</span><br><span class="line">               preNode.right = curNode.right;</span><br><span class="line">               curNode.right = curNode.left;</span><br><span class="line">               cur.left = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="10-1-2-中序遍历（左-中-右）"><a href="#10-1-2-中序遍历（左-中-右）" class="headerlink" title="10.1.2 中序遍历（左-中-右）"></a>10.1.2 中序遍历（左-中-右）</h6><p>若树为空，则空操作返回，否则，从根节点开始（注意：并不是先访问根节点），中序遍历根节点的左子树，然后访问根节点，最后中序遍历根节点的右子树。</p>
<p><strong>注意：</strong>若是二叉搜索树，按照中序遍历的结果为升序排列</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1581339989714.png" alt="1581339989714"></p>
<p>上图按<strong>中序遍历</strong>顺序为：HDIBEJAFKCG</p>
<p><strong>代码实现：</strong></p>
<p>方法一（递归）：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(h)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">inorderRecursion</span><span class="params">(TreeNode node, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        inorder(node.left,array);</span><br><span class="line">        array.add(node);</span><br><span class="line">        inorder(node.right,array);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（迭代）：</p>
<p>时间复杂度：O(n)，其中n是树的节点数</p>
<p>空间复杂度：O(k)，k是栈的最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">inorderIteration</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                array.add(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三（莫里斯算法）：</p>
<p>时间复杂度：O(n)，n是树的节点数</p>
<p>空间复杂度：O(1),没有借助额外的辅助空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">inorderIteration</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        TreeNode curNode = root, preNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curNode.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                array.add(curNode);</span><br><span class="line">                curNode = curNode.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preNode = curNode.left;</span><br><span class="line">                <span class="keyword">while</span>(preNode.right != <span class="keyword">null</span>) preNode = preNode.right;</span><br><span class="line">                TreeNode temp = curNode;</span><br><span class="line">                preNode.right = curNode;</span><br><span class="line">                curNode = curNode.left;</span><br><span class="line">                temp.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="10-1-3-后序遍历（左-右-中）"><a href="#10-1-3-后序遍历（左-右-中）" class="headerlink" title="10.1.3 后序遍历（左-右-中）"></a>10.1.3 后序遍历（左-右-中）</h6><p>若树为空，则空操作返回，否则，从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1581340000812.png" alt="1581340000812"></p>
<p>上图按<strong>后序遍历</strong>顺序为：HIDJEBKFGCA</p>
<p><strong>代码实现：</strong></p>
<p>方法一（递归）：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(h)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;TreeNode&gt; <span class="title">postorderRecursion</span><span class="params">(TreeNode node, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        postorder(node.left,array);</span><br><span class="line">        postorder(node.right,array);</span><br><span class="line">        array.add(node);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（迭代）：</p>
<p>时间复杂度：O(n)，其中n是树的节点数</p>
<p>空间复杂度：O(k)，k是栈的最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">postorderIteration</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == node) &#123;</span><br><span class="line">                    array.add(root);</span><br><span class="line">                    node = root;</span><br><span class="line">                    root = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(root);</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="10-2-广度优先搜索-BFS"><a href="#10-2-广度优先搜索-BFS" class="headerlink" title="10.2 广度优先搜索(BFS)"></a>10.2 广度优先搜索(BFS)</h5><p>若树为空，则空操作返回，否则，从树的第一层，也就是树的根节点开始访问，从上到下逐层遍历，在同一层中，按从左到右的顺序节点逐个访问。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1581340016283.png" alt="1581340016283"></p>
<p>上图按<strong>层序遍历</strong>顺序为：ABCDEFGHIJK</p>
<p><strong>代码实现：</strong></p>
<p>方法一（递归）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">broadFirstSearchRecursion</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;TreeNode&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span>(node != <span class="keyword">null</span>) array.add(node);</span><br><span class="line">		broadFirstSearchRecursion(array, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">broadFirstSearchRecursion</span><span class="params">(ArrayList&lt;TreeNode&gt; array, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = array.size();</span><br><span class="line">		<span class="keyword">if</span>(start == len) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">			TreeNode node = array.get(i);</span><br><span class="line">			<span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">				array.add(node.left);</span><br><span class="line">			<span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">				array.add(node.right);</span><br><span class="line">		&#125;</span><br><span class="line">		broadFirstSearchRecursion(array, len);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（迭代）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;TreeNode&gt; <span class="title">broadFirstSearch</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt; array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          TreeNode node = queue.remove();</span><br><span class="line">          array.add(node);</span><br><span class="line">          <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">          <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
