<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-3 无重复字符的最长子串</title>
    <url>/2020/07/05/LeetCode-3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>方法一：（优化的滑动窗口）</p>
<p>时间复杂度：O(N)  </p>
<p>空间复杂度：O(1) </p>
<p>此方法与方法二思想相似，下面介绍该方法的逻辑，</p>
<p>创建一个长度为128的数组，这是因为ASCII表中所有的值为128，这样创建的目的是数组的下标0-127刚好对应了ASCII表中的值，从字符串s中取出的值刚好作为下标来搜索无重复子串的开始和结束部分用于计算其长度。</p>
<p>对于已存在的ans数组，将从字符串中取出的值作为下标，其位置存储到数组当中，每当从字符串中取得一个值，将其在数组中存放的位置与原无重复子串的起点比较，取出较大的值，如其上一个位置较大，更新起点，否则不更新，然后判断是否更新无重复子串的最大长度。遍历整个字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.charAt(i);</span><br><span class="line">            start = ans[index] &gt; start?ans[index]:start;<span class="comment">//start = Math.max(start,ans[index]);</span></span><br><span class="line">            ans[index] = i+<span class="number">1</span>;</span><br><span class="line">            max = (i-start+<span class="number">1</span>) &gt; max?i-start+<span class="number">1</span>:max;<span class="comment">// max = Math(max,i-start+1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：（优化的滑动窗口）（同方法一）</p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(min(m,n))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(s.charAt(i)))</span><br><span class="line">             start = Math.max(start,map.get(s.charAt(i)));</span><br><span class="line">           max = Math.max(max,i-start+<span class="number">1</span>);</span><br><span class="line">           map.put(s.charAt(i),i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：（滑动窗口）</p>
<p>若集合中不存在该值，将其放入集合当中，若存在该值，则从原无重复子串起点开始，移除值，直到不存在该值时，停止，然后将其放入集合当中，计算长度，判断是否更新最大无重复字串的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目来源： <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3 无重复字符的最长子串</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
</search>
